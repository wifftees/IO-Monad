# Disclaimer

В домашних заданиях вы можете менять сигнатуры методов/конструкторов, если не написано обратного. Если в задании нужно
реализовать определенную функцию, которая уже объявлена за вас, в таких случаях ее сигнатуру менять нельзя. То же
касается и интерфейсов/адт: если задана четкая структура с полями трейтов/классов, то ее можно только дополнять для
удобства вашего решения, но не менять кардинально.

## Важно: автоматические 0 баллов за работу, если:
* Сдано после дедлайна
* Красный CI (даже если падает только `scalafmt`)
* Если CI проходит, но было выполнено 0 тестов
* Есть правки в условии, которые не разрешены в условии
* Если есть действия после дедлайна, которые меняют код 

# IO

Реализуйте все методы со знаками `???` в файле [`MyIO.scala`](./src/main/scala/io/MyIO.scala). Весь функционал `IO` вынесен в класс типов `Computation`. Нужно реализовать экземпляр этого класса типов для класса `MyIO`, а также вспомогательные методы из объекта-компаньона `MyIO` вместе с прокси-методами в классе `MyIO`. За отсутствие реализации у методов будут сниматься баллы.

`MyIO` должно быть стекобезопасным: последовательность вызовов `MyIO` не должна переполнять стек.
В этом задании не стоит заботиться об асинхронности, ваш `MyIO` должен быть полностью синхронным.
В этом задании тесты уже реализованы, менять их не нужно. Если без изменений в тестах все-таки никак, можете писать ассистентам в Telegram-чат.

Суть некоторых из функций:

* `apply` делает то же самое, что и `delay`
* `*>[B](another: MyIO[B]): MyIO[B]` позволяет выстроить последовательность из `MyIO` и `another`, которая вернет результат
  выполнения `another`
* `tailRecM` применяет к значению `A` функцию `A => F[Either[A, B]` до тех пор, пока функция не вернет `B`. Возвращает `B` в контексте `F`.
* `as[B](newValue: => B): MyIO[B]` заменяет значение, содержащееся в `MyIO`, на элемент типа `B`
* `attempt` позволяет трансформировать все ошибки `Error`, произошедшие в `MyIO[A]`, в `MyIO[Either[Error, A]]`
* `option` заменяет ошибки, произошедшие в `MyIO`, на None
* `redeem` возвращает новое `MyIO`, которое трансформирует результат выполнения исходного `MyIO`: обрабатывает ошибки или
  трансформирует успешное значение
* `redeemWith` то же самое, что и `redeem`, но трансформации несут в себе side эффекты
* `raiseError` возвращает ошибку в `MyIO`
* `raiseUnless` возвращает `raiseError`, когда `cond == false`, иначе `MyIO.unit`
* `raiseWhen` возвращает `raiseError`, когда `cond == true`, иначе `MyIO.unit`
* `unlessA` возвращает переданное `MyIO`, если `cond == false`, иначе `MyIO.unit`
* `whenA` возвращает переданное `IO`, если `cond == true`, иначе `MyIO.unit`

Референсы:

* https://typelevel.org/cats-effect/docs/concepts
* https://typelevel.org/cats-effect/api/3.x/cats/effect/IO.html
* https://github.com/typelevel/cats/blob/main/laws/src/main/scala/cats/laws/ApplicativeErrorLaws.scala
* https://github.com/typelevel/cats/blob/main/laws/src/main/scala/cats/laws/MonadErrorLaws.scala

### Code Style:

Мы последовательно вводим список запрещенных механик, которыми нельзя пользоваться при написании кода, и рекомендаций по
code style. За нарушения мы оставляем за собой право **снижать оценку**.

* Переменные и функции должны иметь осмысленные названия;
* Тест классы именуются `<ClassName>Spec`, где `<ClassName>` - класс к которому пишутся тесты;
* Тест классы находятся в том же пакете, что и класс к которому пишутся тесты (например, класс `Fibonacci` находится в
  пакете `fibonacci` в директории `src/main/scala/fibonacci`, значит его тест класс `FibonacciSpec` должен быть в том же
  пакете в директории `src/test/scala/fibonacci`);
* Каждый тест должен быть в отдельном test suite;
* Использовать java коллекции запрещается (Используйте `Scala` коллекции);
* Использовать `mutable` коллекции запрещается;
* Использовать `var` запрещается;
* Использование `this` запрещается (используйте `self`, если надо);
* Использование `return` запрещается;
* Использование `System.exit` запрещается;
* Касты или проверки на типы с помощью методов из Java вроде `asInstanceOf` запрещаются;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`, методы `Monad`, `fold`);
* Использование небезопасных вызовов разрешено только в тестах (например `.get` у `Option`);
* Использование взятия и освобождения примитивов синхронизации: semaphore, mutex - из разных потоков запрещено;
* Использование require для ошибок запрещается
